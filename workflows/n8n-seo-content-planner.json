{
  "name": "SEO Content Planner - Keyword Research & Clustering",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "seo-content-planner",
        "responseMode": "responseNode",
        "options": {
          "responseContentType": "application/json"
        }
      },
      "id": "webhook-trigger",
      "name": "01 Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 300],
      "webhookId": "seo-content-planner-webhook"
    },
    {
      "parameters": {
        "jsCode": "// 02 Validate Input - Prüft Pflichtfelder und Struktur\nconst input = $input.first().json.body || $input.first().json;\n\nconst errors = [];\n\n// Pflichtfeld: topic\nif (!input.topic || typeof input.topic !== 'string' || input.topic.trim().length < 2) {\n  errors.push('Pflichtfeld \"topic\" fehlt oder ist zu kurz (min. 2 Zeichen)');\n}\n\n// Validiere language (optional, default: de)\nif (input.language && !/^[a-z]{2}$/i.test(input.language)) {\n  errors.push('\"language\" muss ein 2-stelliger ISO-Code sein (z.B. \"de\")');\n}\n\n// Validiere location (optional, default: DE)\nif (input.location && !/^[A-Z]{2}$/i.test(input.location)) {\n  errors.push('\"location\" muss ein 2-stelliger Ländercode sein (z.B. \"DE\")');\n}\n\n// Validiere business_goal\nconst validGoals = ['traffic', 'leads', 'sales'];\nif (input.business_goal && !validGoals.includes(input.business_goal)) {\n  errors.push(`\"business_goal\" muss einer von ${validGoals.join(', ')} sein`);\n}\n\n// Validiere max_clusters\nif (input.max_clusters !== undefined) {\n  const mc = parseInt(input.max_clusters);\n  if (isNaN(mc) || mc < 1 || mc > 10) {\n    errors.push('\"max_clusters\" muss zwischen 1 und 10 liegen');\n  }\n}\n\n// Validiere supporting_per_cluster\nif (input.supporting_per_cluster !== undefined) {\n  const spc = parseInt(input.supporting_per_cluster);\n  if (isNaN(spc) || spc < 1 || spc > 10) {\n    errors.push('\"supporting_per_cluster\" muss zwischen 1 und 10 liegen');\n  }\n}\n\n// Validiere seed_keywords (wenn vorhanden)\nif (input.seed_keywords) {\n  if (!Array.isArray(input.seed_keywords)) {\n    errors.push('\"seed_keywords\" muss ein Array sein');\n  } else if (input.seed_keywords.some(k => typeof k !== 'string')) {\n    errors.push('Alle \"seed_keywords\" müssen Strings sein');\n  }\n}\n\n// Validiere dataforseo credentials\nif (!input.dataforseo || !input.dataforseo.login || !input.dataforseo.password) {\n  errors.push('\"dataforseo.login\" und \"dataforseo.password\" sind Pflichtfelder');\n}\n\n// Validiere LLM config (wenn vorhanden)\nif (input.llm && input.llm.provider) {\n  const validProviders = ['openai', 'anthropic', 'none'];\n  if (!validProviders.includes(input.llm.provider)) {\n    errors.push(`\"llm.provider\" muss einer von ${validProviders.join(', ')} sein`);\n  }\n  if (input.llm.provider !== 'none' && !input.llm.api_key) {\n    errors.push(`\"llm.api_key\" ist erforderlich wenn provider \"${input.llm.provider}\" ist`);\n  }\n}\n\nif (errors.length > 0) {\n  return [{\n    json: {\n      valid: false,\n      errors: errors,\n      input: input\n    }\n  }];\n}\n\nreturn [{\n  json: {\n    valid: true,\n    input: input\n  }\n}];"
      },
      "id": "validate-input",
      "name": "02 Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.valid }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-validation",
      "name": "03 Check Validation",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [440, 300]
    },
    {
      "parameters": {
        "jsCode": "// Error Response für ungültige Eingabe\nconst data = $input.first().json;\n\nreturn [{\n  json: {\n    error: true,\n    message: 'Validierungsfehler',\n    details: data.errors,\n    received_input: data.input\n  }\n}];"
      },
      "id": "validation-error",
      "name": "03a Validation Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 480]
    },
    {
      "parameters": {
        "jsCode": "// 04 Normalize Defaults - Setzt Standardwerte und normalisiert Eingabe\nconst input = $input.first().json.input;\nconst crypto = require('crypto');\n\n// Defaults setzen\nconst normalized = {\n  topic: input.topic.trim(),\n  language: (input.language || 'de').toLowerCase(),\n  location: (input.location || 'DE').toUpperCase(),\n  industry: input.industry || null,\n  target_audience: input.target_audience || 'Allgemeine Zielgruppe',\n  business_goal: input.business_goal || 'traffic',\n  seed_keywords: input.seed_keywords || [],\n  max_clusters: parseInt(input.max_clusters) || 4,\n  supporting_per_cluster: parseInt(input.supporting_per_cluster) || 5,\n  include_commercial_piece: input.include_commercial_piece !== false,\n  dataforseo: {\n    login: input.dataforseo.login,\n    password: input.dataforseo.password\n  },\n  llm: {\n    provider: input.llm?.provider || 'none',\n    api_key: input.llm?.api_key || null,\n    model: input.llm?.model || null\n  }\n};\n\n// Primary Intent basierend auf business_goal\nconst intentMap = {\n  'traffic': 'informational',\n  'leads': 'commercial',\n  'sales': 'transactional'\n};\nnormalized.primary_intent = intentMap[normalized.business_goal];\n\n// Tone/Angle Beschreibung\nconst toneMap = {\n  'traffic': 'Informativ, lehrreich, problemlösend',\n  'leads': 'Beratend, vergleichend, entscheidungshelfend',\n  'sales': 'Überzeugend, handlungsorientiert, produktfokussiert'\n};\nnormalized.tone_angle = toneMap[normalized.business_goal];\n\n// Request ID für Idempotenz (Hash aus topic + language + location + seeds)\nconst idSource = `${normalized.topic}|${normalized.language}|${normalized.location}|${normalized.seed_keywords.sort().join(',')}`;\nnormalized.request_id = crypto.createHash('sha256').update(idSource).digest('hex').substring(0, 16);\n\n// Location Code für DATAFORSEO (Mapping)\nconst locationCodes = {\n  'DE': 2276, 'AT': 2040, 'CH': 2756, 'US': 2840, 'GB': 2826,\n  'FR': 2250, 'ES': 2724, 'IT': 2380, 'NL': 2528, 'PL': 2616\n};\nnormalized.dataforseo_location_code = locationCodes[normalized.location] || 2276;\n\n// Language Code für DATAFORSEO\nconst langCodes = {\n  'de': 'de', 'en': 'en', 'fr': 'fr', 'es': 'es', 'it': 'it', 'nl': 'nl', 'pl': 'pl'\n};\nnormalized.dataforseo_language_code = langCodes[normalized.language] || 'de';\n\n// Timestamp\nnormalized.generated_at = new Date().toISOString();\n\n// Assumptions tracking\nnormalized.assumptions = [];\nif (!input.seed_keywords || input.seed_keywords.length === 0) {\n  normalized.assumptions.push('Seed-Keywords wurden automatisch generiert');\n}\nif (!input.target_audience) {\n  normalized.assumptions.push('Zielgruppe wurde als \"Allgemeine Zielgruppe\" angenommen');\n}\nif (!input.llm || input.llm.provider === 'none') {\n  normalized.assumptions.push('Kein LLM konfiguriert - heuristische Methoden werden verwendet');\n}\n\nreturn [{ json: normalized }];"
      },
      "id": "normalize-defaults",
      "name": "04 Normalize Defaults",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.seed_keywords.length > 0 }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-seeds-exist",
      "name": "05 Seeds vorhanden?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [880, 300]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.llm.provider }}",
              "operation": "notEquals",
              "value2": "none"
            }
          ]
        }
      },
      "id": "check-llm-for-seeds",
      "name": "06 LLM für Seeds?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1100, 480]
    },
    {
      "parameters": {
        "jsCode": "// 06a Heuristische Seed-Generierung ohne LLM\nconst data = $input.first().json;\nconst topic = data.topic;\nconst language = data.language;\n\n// Präfixe und Suffixe für Seed-Generierung\nconst prefixes_de = ['was ist', 'wie', 'warum', 'beste', 'top', 'anleitung', 'tipps'];\nconst suffixes_de = ['definition', 'beispiele', 'tools', 'software', 'anbieter', 'vergleich', 'kosten', 'vorteile'];\nconst prefixes_en = ['what is', 'how to', 'why', 'best', 'top', 'guide', 'tips'];\nconst suffixes_en = ['definition', 'examples', 'tools', 'software', 'comparison', 'cost', 'benefits'];\n\nconst prefixes = language === 'de' ? prefixes_de : prefixes_en;\nconst suffixes = language === 'de' ? suffixes_de : suffixes_en;\n\nconst seeds = new Set();\n\n// Basis-Keyword\nseeds.add(topic.toLowerCase());\n\n// Mit Präfixen\nprefixes.slice(0, 4).forEach(prefix => {\n  seeds.add(`${prefix} ${topic}`.toLowerCase());\n});\n\n// Mit Suffixen\nsuffixes.slice(0, 4).forEach(suffix => {\n  seeds.add(`${topic} ${suffix}`.toLowerCase());\n});\n\n// Business Goal spezifische Seeds\nif (data.business_goal === 'leads') {\n  seeds.add(`${topic} anbieter`.toLowerCase());\n  seeds.add(`${topic} beratung`.toLowerCase());\n} else if (data.business_goal === 'sales') {\n  seeds.add(`${topic} kaufen`.toLowerCase());\n  seeds.add(`${topic} preise`.toLowerCase());\n}\n\nconst seedArray = Array.from(seeds).slice(0, 10);\n\nreturn [{\n  json: {\n    ...data,\n    seed_keywords: seedArray,\n    seeds_generated_by: 'heuristic'\n  }\n}];"
      },
      "id": "generate-seeds-heuristic",
      "name": "06a Generate Seeds (Heuristic)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1320, 600]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $json.llm.provider === 'openai' ? 'https://api.openai.com/v1/chat/completions' : 'https://api.anthropic.com/v1/messages' }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "={{ $json.llm.provider === 'openai' ? 'Authorization' : 'x-api-key' }}",
              "value": "={{ $json.llm.provider === 'openai' ? 'Bearer ' + $json.llm.api_key : $json.llm.api_key }}"
            },
            {
              "name": "={{ $json.llm.provider === 'anthropic' ? 'anthropic-version' : 'X-Dummy' }}",
              "value": "={{ $json.llm.provider === 'anthropic' ? '2023-06-01' : 'ignore' }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.llm.provider === 'openai' ? JSON.stringify({\n  model: $json.llm.model || 'gpt-4o-mini',\n  messages: [{\n    role: 'system',\n    content: 'Du bist ein SEO-Experte. Generiere Seed-Keywords für Keyword-Research. Antworte NUR mit einem JSON-Array von Strings, keine Erklärung.'\n  }, {\n    role: 'user',\n    content: `Generiere 8-10 relevante Seed-Keywords für das Thema \"${$json.topic}\" im Kontext von ${$json.industry || 'allgemein'}. Zielgruppe: ${$json.target_audience}. Business Goal: ${$json.business_goal}. Sprache: ${$json.language}. Antworte NUR mit einem JSON-Array.`\n  }],\n  temperature: 0.7\n}) : JSON.stringify({\n  model: $json.llm.model || 'claude-3-haiku-20240307',\n  max_tokens: 500,\n  messages: [{\n    role: 'user',\n    content: `Du bist ein SEO-Experte. Generiere 8-10 relevante Seed-Keywords für das Thema \"${$json.topic}\" im Kontext von ${$json.industry || 'allgemein'}. Zielgruppe: ${$json.target_audience}. Business Goal: ${$json.business_goal}. Sprache: ${$json.language}. Antworte NUR mit einem JSON-Array von Strings, keine Erklärung.`\n  }]\n}) }}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "llm-generate-seeds",
      "name": "06b LLM Generate Seeds",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1320, 360],
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 2000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM Response für Seeds\nconst originalData = $('06 LLM für Seeds?').first().json;\nconst llmResponse = $input.first().json;\n\nlet seeds = [];\n\ntry {\n  // OpenAI Format\n  if (llmResponse.choices && llmResponse.choices[0]) {\n    const content = llmResponse.choices[0].message.content;\n    seeds = JSON.parse(content);\n  }\n  // Anthropic Format\n  else if (llmResponse.content && llmResponse.content[0]) {\n    const content = llmResponse.content[0].text;\n    // Extrahiere JSON aus Antwort\n    const jsonMatch = content.match(/\\[.*\\]/s);\n    if (jsonMatch) {\n      seeds = JSON.parse(jsonMatch[0]);\n    }\n  }\n} catch (e) {\n  // Fallback bei Parse-Fehler\n  seeds = [];\n}\n\n// Wenn keine Seeds, Fallback zu Heuristik\nif (!seeds || seeds.length === 0) {\n  const topic = originalData.topic;\n  const prefixes = ['was ist', 'wie', 'beste', 'top', 'anleitung'];\n  seeds = [topic.toLowerCase()];\n  prefixes.forEach(p => seeds.push(`${p} ${topic}`.toLowerCase()));\n}\n\nreturn [{\n  json: {\n    ...originalData,\n    seed_keywords: seeds.slice(0, 10),\n    seeds_generated_by: 'llm'\n  }\n}];"
      },
      "id": "parse-llm-seeds",
      "name": "06c Parse LLM Seeds",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1540, 360]
    },
    {
      "parameters": {
        "mode": "combine",
        "mergeByFields": {
          "values": [
            {
              "field1": "request_id",
              "field2": "request_id"
            }
          ]
        },
        "options": {}
      },
      "id": "merge-seeds",
      "name": "07 Merge Seeds",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1760, 400]
    },
    {
      "parameters": {
        "jsCode": "// Bereite DATAFORSEO Batch-Anfragen vor\nconst data = $input.first().json;\nconst seeds = data.seed_keywords;\n\n// DATAFORSEO erlaubt bis zu 100 Keywords pro Request\n// Wir teilen in Batches von 10 für bessere Rate-Limit-Handhabung\nconst batchSize = 10;\nconst batches = [];\n\nfor (let i = 0; i < seeds.length; i += batchSize) {\n  batches.push({\n    batch_index: Math.floor(i / batchSize),\n    keywords: seeds.slice(i, i + batchSize),\n    location_code: data.dataforseo_location_code,\n    language_code: data.dataforseo_language_code,\n    dataforseo_login: data.dataforseo.login,\n    dataforseo_password: data.dataforseo.password,\n    original_data: data\n  });\n}\n\nreturn batches.map(b => ({ json: b }));"
      },
      "id": "prepare-dataforseo-batches",
      "name": "08 Prepare DataForSEO Batches",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1980, 400]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "split-batches",
      "name": "09 Split Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [2200, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.dataforseo.com/v3/keywords_data/google_ads/search_volume/live",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify([{\n  keywords: $json.keywords,\n  location_code: $json.location_code,\n  language_code: $json.language_code\n}]) }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "dataforseo-search-volume",
      "name": "10 DataForSEO Search Volume",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2420, 400],
      "credentials": {
        "httpBasicAuth": {
          "id": "dataforseo-creds",
          "name": "DataForSEO"
        }
      },
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "unit": "seconds",
        "amount": 1
      },
      "id": "wait-rate-limit",
      "name": "11 Wait (Rate Limit)",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [2640, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.dataforseo.com/v3/keywords_data/google_ads/keywords_for_keywords/live",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify([{\n  keywords: $('09 Split Batches').first().json.keywords,\n  location_code: $('09 Split Batches').first().json.location_code,\n  language_code: $('09 Split Batches').first().json.language_code\n}]) }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "dataforseo-related-keywords",
      "name": "12 DataForSEO Related Keywords",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2860, 400],
      "credentials": {
        "httpBasicAuth": {
          "id": "dataforseo-creds",
          "name": "DataForSEO"
        }
      },
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Parse und kombiniere DataForSEO Ergebnisse aus aktuellem Batch\nconst batchData = $('09 Split Batches').first().json;\nconst searchVolumeResponse = $('10 DataForSEO Search Volume').first().json;\nconst relatedResponse = $('12 DataForSEO Related Keywords').first().json;\n\nconst keywords = [];\nconst processedKeywords = new Set();\n\n// Funktion zum Extrahieren von Keyword-Daten\nfunction extractKeyword(item, source) {\n  if (!item || !item.keyword) return null;\n  const kw = item.keyword.toLowerCase().trim();\n  if (processedKeywords.has(kw)) return null;\n  processedKeywords.add(kw);\n  \n  return {\n    keyword: kw,\n    volume: item.search_volume || 0,\n    cpc: item.cpc || 0,\n    competition: item.competition || 0,\n    competition_index: item.competition_index || 0,\n    difficulty: Math.round((item.competition_index || 0) * 100),\n    intent_guess: guessIntent(kw),\n    parent_topic_guess: guessParentTopic(kw, batchData.original_data.topic),\n    source: source\n  };\n}\n\n// Intent-Heuristik\nfunction guessIntent(keyword) {\n  const kw = keyword.toLowerCase();\n  if (/kaufen|preis|kosten|bestellen|shop|angebot|rabatt|günstig|billig|buy|price|order|cheap/.test(kw)) {\n    return 'transactional';\n  }\n  if (/beste|vergleich|test|review|bewertung|erfahrung|alternative|vs|comparison|best|top/.test(kw)) {\n    return 'commercial';\n  }\n  if (/was ist|wie|warum|definition|bedeutung|erklärung|anleitung|tutorial|guide|what|how|why/.test(kw)) {\n    return 'informational';\n  }\n  return 'informational';\n}\n\n// Parent Topic Heuristik\nfunction guessParentTopic(keyword, mainTopic) {\n  const kw = keyword.toLowerCase();\n  const topic = mainTopic.toLowerCase();\n  \n  // Entferne häufige Präfixe/Suffixe\n  let parent = kw\n    .replace(/^(was ist|wie|warum|beste|top|anleitung|tipps für)\\s+/i, '')\n    .replace(/\\s+(definition|beispiele|tools|software|anbieter|vergleich|kosten|vorteile|kaufen|preis)$/i, '');\n  \n  // Wenn das Hauptthema enthalten ist, ist es das Parent Topic\n  if (kw.includes(topic)) {\n    return mainTopic;\n  }\n  \n  return parent || mainTopic;\n}\n\n// Search Volume Ergebnisse verarbeiten\ntry {\n  if (searchVolumeResponse.tasks && searchVolumeResponse.tasks[0]?.result) {\n    searchVolumeResponse.tasks[0].result.forEach(item => {\n      const kw = extractKeyword(item, 'dataforseo_search_volume');\n      if (kw) keywords.push(kw);\n    });\n  }\n} catch (e) {\n  // Ignore parsing errors\n}\n\n// Related Keywords Ergebnisse verarbeiten\ntry {\n  if (relatedResponse.tasks && relatedResponse.tasks[0]?.result) {\n    relatedResponse.tasks[0].result.forEach(item => {\n      const kw = extractKeyword(item, 'dataforseo_related');\n      if (kw) keywords.push(kw);\n    });\n  }\n} catch (e) {\n  // Ignore parsing errors\n}\n\nreturn [{\n  json: {\n    batch_index: batchData.batch_index,\n    keywords: keywords,\n    original_data: batchData.original_data,\n    api_success: keywords.length > 0\n  }\n}];"
      },
      "id": "parse-dataforseo-results",
      "name": "13 Parse DataForSEO Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3080, 400]
    },
    {
      "parameters": {
        "jsCode": "// Sammle alle Keywords aus allen Batches\nconst allItems = $input.all();\nlet allKeywords = [];\nlet originalData = null;\nlet apiSuccess = false;\n\nallItems.forEach(item => {\n  if (item.json.keywords) {\n    allKeywords = allKeywords.concat(item.json.keywords);\n  }\n  if (item.json.original_data) {\n    originalData = item.json.original_data;\n  }\n  if (item.json.api_success) {\n    apiSuccess = true;\n  }\n});\n\n// Deduplizieren\nconst seen = new Set();\nconst uniqueKeywords = allKeywords.filter(kw => {\n  if (seen.has(kw.keyword)) return false;\n  seen.add(kw.keyword);\n  return true;\n});\n\nreturn [{\n  json: {\n    keywords: uniqueKeywords,\n    original_data: originalData,\n    api_success: apiSuccess\n  }\n}];"
      },
      "id": "collect-all-keywords",
      "name": "14 Collect All Keywords",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3300, 400]
    },
    {
      "parameters": {
        "jsCode": "// Keyword Cleaning und Scoring\nconst data = $input.first().json;\nconst originalData = data.original_data;\nlet keywords = data.keywords || [];\n\nconst topic = originalData.topic.toLowerCase();\nconst minVolume = 10;\nconst minLength = 3;\n\n// Stoppwörter für Filterung\nconst stopwords = new Set(['der', 'die', 'das', 'und', 'oder', 'ein', 'eine', 'the', 'a', 'an', 'and', 'or']);\n\n// Cleaning Rules\nfunction isValidKeyword(kw) {\n  const keyword = kw.keyword;\n  \n  // Zu kurz\n  if (keyword.length < minLength) return false;\n  \n  // Nur Stoppwörter\n  const words = keyword.split(/\\s+/);\n  if (words.every(w => stopwords.has(w.toLowerCase()))) return false;\n  \n  // Offensichtlich irrelevant (enthält keine Topic-Wörter und kein semantischer Bezug)\n  const topicWords = topic.split(/\\s+/);\n  const hasTopicRelation = topicWords.some(tw => \n    keyword.includes(tw) || tw.includes(keyword.split(/\\s+/)[0])\n  );\n  \n  // Mindestvolumen (außer bei sehr relevanten Keywords)\n  if (kw.volume < minVolume && !hasTopicRelation) return false;\n  \n  return true;\n}\n\n// Scoring Funktion\nfunction scoreKeyword(kw) {\n  let score = 0;\n  \n  // Volumen-Score (log-skaliert)\n  score += Math.log10(Math.max(kw.volume, 1)) * 10;\n  \n  // CPC als Indikator für kommerzielle Relevanz\n  score += Math.min(kw.cpc * 2, 20);\n  \n  // Niedrigere Difficulty ist besser\n  score += (100 - kw.difficulty) * 0.3;\n  \n  // Topic-Relevanz Bonus\n  const topicWords = topic.split(/\\s+/);\n  if (topicWords.some(tw => kw.keyword.includes(tw))) {\n    score += 15;\n  }\n  \n  // Intent-Alignment mit Business Goal\n  const goalIntentMap = {\n    'traffic': 'informational',\n    'leads': 'commercial',\n    'sales': 'transactional'\n  };\n  if (kw.intent_guess === goalIntentMap[originalData.business_goal]) {\n    score += 10;\n  }\n  \n  return Math.round(score * 100) / 100;\n}\n\n// Filter und Score\nkeywords = keywords\n  .filter(isValidKeyword)\n  .map(kw => ({\n    ...kw,\n    relevance_score: scoreKeyword(kw)\n  }))\n  .sort((a, b) => b.relevance_score - a.relevance_score);\n\n// Limitiere auf Top 100\nkeywords = keywords.slice(0, 100);\n\n// Wenn keine Keywords, Flag setzen\nconst dataIncomplete = keywords.length === 0;\n\nif (dataIncomplete) {\n  // Fallback: Seed Keywords als Basis\n  keywords = originalData.seed_keywords.map((kw, i) => ({\n    keyword: kw,\n    volume: 0,\n    cpc: 0,\n    difficulty: 50,\n    intent_guess: originalData.primary_intent,\n    parent_topic_guess: originalData.topic,\n    source: 'seed_fallback',\n    relevance_score: 100 - i\n  }));\n}\n\nreturn [{\n  json: {\n    keywords: keywords,\n    original_data: originalData,\n    data_incomplete: dataIncomplete,\n    keyword_count: keywords.length\n  }\n}];"
      },
      "id": "keyword-cleaning",
      "name": "15 Keyword Cleaning & Scoring",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3520, 400]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.original_data.llm.provider }}",
              "operation": "notEquals",
              "value2": "none"
            }
          ]
        }
      },
      "id": "check-llm-for-clustering",
      "name": "16 LLM für Clustering?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [3740, 400]
    },
    {
      "parameters": {
        "jsCode": "// Heuristisches Clustering ohne LLM\nconst data = $input.first().json;\nconst keywords = data.keywords;\nconst originalData = data.original_data;\nconst maxClusters = originalData.max_clusters;\n\n// Token-basiertes Clustering\nfunction tokenize(text) {\n  return text.toLowerCase()\n    .replace(/[^a-zäöüß0-9\\s]/g, '')\n    .split(/\\s+/)\n    .filter(t => t.length > 2);\n}\n\nfunction getSharedTokens(kw1, kw2) {\n  const tokens1 = new Set(tokenize(kw1));\n  const tokens2 = tokenize(kw2);\n  return tokens2.filter(t => tokens1.has(t)).length;\n}\n\n// Initiale Cluster basierend auf Parent Topics\nconst parentTopicGroups = {};\nkeywords.forEach(kw => {\n  const parent = kw.parent_topic_guess || originalData.topic;\n  if (!parentTopicGroups[parent]) {\n    parentTopicGroups[parent] = [];\n  }\n  parentTopicGroups[parent].push(kw);\n});\n\n// Sortiere Gruppen nach Gesamtvolumen\nconst sortedGroups = Object.entries(parentTopicGroups)\n  .map(([name, kws]) => ({\n    name: name,\n    keywords: kws,\n    total_volume: kws.reduce((sum, k) => sum + k.volume, 0)\n  }))\n  .sort((a, b) => b.total_volume - a.total_volume);\n\n// Merge kleine Gruppen und limitiere auf maxClusters\nlet clusters = [];\nconst minClusterSize = 3;\n\nsortedGroups.forEach(group => {\n  if (clusters.length < maxClusters && group.keywords.length >= minClusterSize) {\n    clusters.push(group);\n  } else if (clusters.length > 0) {\n    // Füge zu ähnlichstem Cluster hinzu\n    let bestMatch = 0;\n    let bestScore = 0;\n    clusters.forEach((c, i) => {\n      const score = getSharedTokens(group.name, c.name);\n      if (score > bestScore) {\n        bestScore = score;\n        bestMatch = i;\n      }\n    });\n    clusters[bestMatch].keywords = clusters[bestMatch].keywords.concat(group.keywords);\n    clusters[bestMatch].total_volume += group.total_volume;\n  }\n});\n\n// Wenn zu wenige Cluster, erstelle basierend auf Intent\nif (clusters.length < 2 && keywords.length >= 10) {\n  const intentGroups = {};\n  keywords.forEach(kw => {\n    const intent = kw.intent_guess || 'informational';\n    if (!intentGroups[intent]) intentGroups[intent] = [];\n    intentGroups[intent].push(kw);\n  });\n  \n  clusters = Object.entries(intentGroups)\n    .map(([intent, kws]) => ({\n      name: `${originalData.topic} - ${intent}`,\n      keywords: kws,\n      total_volume: kws.reduce((sum, k) => sum + k.volume, 0)\n    }))\n    .slice(0, maxClusters);\n}\n\n// Formatiere Cluster-Output\nconst formattedClusters = clusters.map((cluster, index) => {\n  // Sortiere Keywords nach Relevanz\n  const sortedKws = cluster.keywords.sort((a, b) => b.relevance_score - a.relevance_score);\n  \n  // Core Keyword = höchstes Volumen mit passender Intent\n  const coreKw = sortedKws.reduce((best, kw) => \n    (kw.volume > best.volume) ? kw : best\n  , sortedKws[0]);\n  \n  // Cluster Goal basierend auf dominanter Intent\n  const intentCounts = {};\n  sortedKws.forEach(kw => {\n    intentCounts[kw.intent_guess] = (intentCounts[kw.intent_guess] || 0) + 1;\n  });\n  const dominantIntent = Object.entries(intentCounts)\n    .sort((a, b) => b[1] - a[1])[0][0];\n  \n  const goalMap = {\n    'informational': 'traffic',\n    'commercial': 'leads',\n    'transactional': 'sales'\n  };\n  \n  return {\n    cluster_id: index + 1,\n    cluster_name: cluster.name,\n    core_keyword: coreKw.keyword,\n    cluster_goal: goalMap[dominantIntent] || 'traffic',\n    keywords: sortedKws.slice(0, 20).map(k => k.keyword),\n    keyword_details: sortedKws.slice(0, 20),\n    total_volume: cluster.total_volume\n  };\n});\n\nreturn [{\n  json: {\n    clusters: formattedClusters,\n    original_data: originalData,\n    all_keywords: keywords,\n    data_incomplete: data.data_incomplete,\n    clustering_method: 'heuristic'\n  }\n}];"
      },
      "id": "cluster-heuristic",
      "name": "16a Cluster (Heuristic)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3960, 580]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $json.original_data.llm.provider === 'openai' ? 'https://api.openai.com/v1/chat/completions' : 'https://api.anthropic.com/v1/messages' }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "={{ $json.original_data.llm.provider === 'openai' ? 'Authorization' : 'x-api-key' }}",
              "value": "={{ $json.original_data.llm.provider === 'openai' ? 'Bearer ' + $json.original_data.llm.api_key : $json.original_data.llm.api_key }}"
            },
            {
              "name": "={{ $json.original_data.llm.provider === 'anthropic' ? 'anthropic-version' : 'X-Dummy' }}",
              "value": "={{ $json.original_data.llm.provider === 'anthropic' ? '2023-06-01' : 'ignore' }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ (() => {\n  const data = $json;\n  const keywords = data.keywords.slice(0, 50).map(k => `${k.keyword} (vol: ${k.volume}, intent: ${k.intent_guess})`);\n  const prompt = `Du bist ein SEO-Experte für Keyword-Clustering. Analysiere diese Keywords und erstelle ${data.original_data.max_clusters} semantische Cluster für Content-Hubs.\n\nHauptthema: ${data.original_data.topic}\nBusiness Goal: ${data.original_data.business_goal}\nZielgruppe: ${data.original_data.target_audience}\n\nKeywords:\n${keywords.join('\\n')}\n\nErstelle Cluster im folgenden JSON-Format (NUR JSON, keine Erklärung):\n[\n  {\n    \"cluster_name\": \"Name des Clusters\",\n    \"core_keyword\": \"Haupt-Keyword mit höchstem Volumen\",\n    \"cluster_goal\": \"traffic|leads|sales\",\n    \"keywords\": [\"keyword1\", \"keyword2\", ...]\n  }\n]`;\n\n  if (data.original_data.llm.provider === 'openai') {\n    return JSON.stringify({\n      model: data.original_data.llm.model || 'gpt-4o-mini',\n      messages: [\n        { role: 'system', content: 'Du bist ein SEO-Experte. Antworte NUR mit validem JSON.' },\n        { role: 'user', content: prompt }\n      ],\n      temperature: 0.5\n    });\n  } else {\n    return JSON.stringify({\n      model: data.original_data.llm.model || 'claude-3-haiku-20240307',\n      max_tokens: 2000,\n      messages: [{ role: 'user', content: prompt }]\n    });\n  }\n})() }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "llm-clustering",
      "name": "16b LLM Clustering",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3960, 220],
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 3000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM Clustering Response\nconst previousData = $('16 LLM für Clustering?').first().json;\nconst llmResponse = $input.first().json;\n\nlet clusters = [];\n\ntry {\n  let content = '';\n  \n  // OpenAI Format\n  if (llmResponse.choices && llmResponse.choices[0]) {\n    content = llmResponse.choices[0].message.content;\n  }\n  // Anthropic Format\n  else if (llmResponse.content && llmResponse.content[0]) {\n    content = llmResponse.content[0].text;\n  }\n  \n  // Extrahiere JSON\n  const jsonMatch = content.match(/\\[\\s*\\{[\\s\\S]*\\}\\s*\\]/s);\n  if (jsonMatch) {\n    clusters = JSON.parse(jsonMatch[0]);\n  }\n} catch (e) {\n  clusters = [];\n}\n\n// Wenn Parsing fehlschlägt, Fallback zu heuristischem Clustering\nif (!clusters || clusters.length === 0) {\n  // Einfaches Fallback-Clustering\n  const kws = previousData.keywords;\n  clusters = [{\n    cluster_name: previousData.original_data.topic,\n    core_keyword: kws[0]?.keyword || previousData.original_data.topic,\n    cluster_goal: previousData.original_data.business_goal,\n    keywords: kws.slice(0, 20).map(k => k.keyword)\n  }];\n}\n\n// Formatiere und ergänze Cluster-Daten\nconst formattedClusters = clusters.map((cluster, index) => {\n  // Finde Keyword-Details\n  const keywordDetails = cluster.keywords.map(kw => {\n    const found = previousData.keywords.find(k => k.keyword === kw);\n    return found || {\n      keyword: kw,\n      volume: 0,\n      cpc: 0,\n      difficulty: 50,\n      intent_guess: 'informational',\n      parent_topic_guess: cluster.cluster_name,\n      source: 'llm_cluster'\n    };\n  });\n  \n  return {\n    cluster_id: index + 1,\n    cluster_name: cluster.cluster_name,\n    core_keyword: cluster.core_keyword,\n    cluster_goal: cluster.cluster_goal || previousData.original_data.business_goal,\n    keywords: cluster.keywords,\n    keyword_details: keywordDetails,\n    total_volume: keywordDetails.reduce((sum, k) => sum + (k.volume || 0), 0)\n  };\n});\n\nreturn [{\n  json: {\n    clusters: formattedClusters,\n    original_data: previousData.original_data,\n    all_keywords: previousData.keywords,\n    data_incomplete: previousData.data_incomplete,\n    clustering_method: 'llm'\n  }\n}];"
      },
      "id": "parse-llm-clusters",
      "name": "16c Parse LLM Clusters",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4180, 220]
    },
    {
      "parameters": {
        "mode": "combine",
        "mergeByFields": {
          "values": [
            {
              "field1": "original_data.request_id",
              "field2": "original_data.request_id"
            }
          ]
        },
        "options": {}
      },
      "id": "merge-clusters",
      "name": "17 Merge Clusters",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [4400, 400]
    },
    {
      "parameters": {
        "jsCode": "// Content Piece Generierung - Pillar, Supporting, Commercial\nconst data = $input.first().json;\nconst clusters = data.clusters;\nconst originalData = data.original_data;\nconst supportingPerCluster = originalData.supporting_per_cluster;\nconst includeCommercial = originalData.include_commercial_piece;\nconst language = originalData.language;\n\n// Outline Templates\nconst outlineTemplates = {\n  pillar: {\n    de: [\n      { h: 'H1', t: '{title}' },\n      { h: 'H2', t: 'Einleitung: Das Problem und die Lösung' },\n      { h: 'H2', t: 'Was ist {keyword}? Definition und Grundlagen' },\n      { h: 'H2', t: 'Warum ist {keyword} wichtig? Die wichtigsten Vorteile' },\n      { h: 'H2', t: 'Anwendungsbereiche und Use Cases' },\n      { h: 'H3', t: 'Use Case 1: {use_case_1}' },\n      { h: 'H3', t: 'Use Case 2: {use_case_2}' },\n      { h: 'H2', t: '{keyword} Schritt für Schritt umsetzen' },\n      { h: 'H2', t: 'Häufige Fehler vermeiden + Profi-Tipps' },\n      { h: 'H2', t: 'Tools und Software für {keyword}' },\n      { h: 'H2', t: 'Häufig gestellte Fragen (FAQ)' },\n      { h: 'H2', t: 'Fazit und nächste Schritte' }\n    ],\n    en: [\n      { h: 'H1', t: '{title}' },\n      { h: 'H2', t: 'Introduction: The Problem and Solution' },\n      { h: 'H2', t: 'What is {keyword}? Definition and Basics' },\n      { h: 'H2', t: 'Why {keyword} Matters: Key Benefits' },\n      { h: 'H2', t: 'Use Cases and Applications' },\n      { h: 'H3', t: 'Use Case 1: {use_case_1}' },\n      { h: 'H3', t: 'Use Case 2: {use_case_2}' },\n      { h: 'H2', t: 'Step-by-Step Implementation Guide' },\n      { h: 'H2', t: 'Common Mistakes and Pro Tips' },\n      { h: 'H2', t: 'Best Tools and Software' },\n      { h: 'H2', t: 'Frequently Asked Questions' },\n      { h: 'H2', t: 'Conclusion and Next Steps' }\n    ]\n  },\n  supporting: {\n    de: [\n      { h: 'H1', t: '{title}' },\n      { h: 'H2', t: 'Das Problem: Warum {keyword} relevant ist' },\n      { h: 'H2', t: '{keyword}: Schritt-für-Schritt Anleitung' },\n      { h: 'H2', t: 'Praktische Beispiele' },\n      { h: 'H2', t: 'Best Practices und häufige Fehler' },\n      { h: 'H2', t: 'FAQ zu {keyword}' },\n      { h: 'H2', t: 'Fazit' }\n    ],\n    en: [\n      { h: 'H1', t: '{title}' },\n      { h: 'H2', t: 'The Problem: Why {keyword} Matters' },\n      { h: 'H2', t: '{keyword}: Step-by-Step Guide' },\n      { h: 'H2', t: 'Practical Examples' },\n      { h: 'H2', t: 'Best Practices and Common Mistakes' },\n      { h: 'H2', t: 'FAQ about {keyword}' },\n      { h: 'H2', t: 'Conclusion' }\n    ]\n  },\n  commercial: {\n    de: [\n      { h: 'H1', t: '{title}' },\n      { h: 'H2', t: 'Kurzfazit: Unsere Empfehlung' },\n      { h: 'H2', t: 'Vergleichstabelle: {keyword} im Überblick' },\n      { h: 'H2', t: 'Wichtige Auswahlkriterien' },\n      { h: 'H2', t: 'Top-Optionen im Detail' },\n      { h: 'H3', t: 'Option 1: {option_1}' },\n      { h: 'H3', t: 'Option 2: {option_2}' },\n      { h: 'H2', t: 'Alternativen und Sonderfälle' },\n      { h: 'H2', t: 'FAQ' },\n      { h: 'H2', t: 'Fazit: Die richtige Wahl treffen' }\n    ],\n    en: [\n      { h: 'H1', t: '{title}' },\n      { h: 'H2', t: 'Quick Summary: Our Recommendation' },\n      { h: 'H2', t: 'Comparison Table: {keyword} Overview' },\n      { h: 'H2', t: 'Key Selection Criteria' },\n      { h: 'H2', t: 'Top Options in Detail' },\n      { h: 'H3', t: 'Option 1: {option_1}' },\n      { h: 'H3', t: 'Option 2: {option_2}' },\n      { h: 'H2', t: 'Alternatives and Special Cases' },\n      { h: 'H2', t: 'FAQ' },\n      { h: 'H2', t: 'Conclusion: Making the Right Choice' }\n    ]\n  }\n};\n\n// Titel-Templates\nconst titleTemplates = {\n  pillar: {\n    de: [\n      '{keyword}: Der komplette Guide für {year}',\n      '{keyword} verstehen und meistern: Alles was du wissen musst',\n      'Was ist {keyword}? Definition, Vorteile & Anleitung'\n    ],\n    en: [\n      '{keyword}: The Complete Guide for {year}',\n      'Understanding {keyword}: Everything You Need to Know',\n      'What is {keyword}? Definition, Benefits & Guide'\n    ]\n  },\n  supporting: {\n    de: [\n      '{keyword}: Praktische Anleitung mit Beispielen',\n      'Wie du {keyword} erfolgreich umsetzt',\n      '{keyword} einfach erklärt + Tipps'\n    ],\n    en: [\n      '{keyword}: Practical Guide with Examples',\n      'How to Successfully Implement {keyword}',\n      '{keyword} Explained Simply + Tips'\n    ]\n  },\n  commercial: {\n    de: [\n      'Beste {keyword}: Top-Anbieter im Vergleich {year}',\n      '{keyword} Vergleich: Die besten Optionen',\n      '{keyword} Test & Empfehlungen {year}'\n    ],\n    en: [\n      'Best {keyword}: Top Providers Compared {year}',\n      '{keyword} Comparison: The Best Options',\n      '{keyword} Review & Recommendations {year}'\n    ]\n  }\n};\n\n// FAQ Templates\nconst faqTemplates = {\n  de: [\n    'Was kostet {keyword}?',\n    'Wie lange dauert es, {keyword} zu lernen/implementieren?',\n    'Welche Voraussetzungen brauche ich für {keyword}?',\n    'Ist {keyword} für Anfänger geeignet?',\n    'Was sind die häufigsten Fehler bei {keyword}?',\n    'Welche Alternativen gibt es zu {keyword}?',\n    'Wie fange ich mit {keyword} an?',\n    'Lohnt sich {keyword} für kleine Unternehmen?'\n  ],\n  en: [\n    'How much does {keyword} cost?',\n    'How long does it take to learn/implement {keyword}?',\n    'What prerequisites do I need for {keyword}?',\n    'Is {keyword} suitable for beginners?',\n    'What are the most common mistakes with {keyword}?',\n    'What alternatives are there to {keyword}?',\n    'How do I get started with {keyword}?',\n    'Is {keyword} worth it for small businesses?'\n  ]\n};\n\n// Helper Funktionen\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction slugify(str) {\n  return str.toLowerCase()\n    .replace(/ä/g, 'ae').replace(/ö/g, 'oe').replace(/ü/g, 'ue').replace(/ß/g, 'ss')\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-|-$/g, '');\n}\n\nfunction fillTemplate(template, vars) {\n  let result = template;\n  Object.entries(vars).forEach(([key, value]) => {\n    result = result.replace(new RegExp(`\\\\{${key}\\\\}`, 'g'), value);\n  });\n  return result;\n}\n\nfunction selectRandom(arr) {\n  return arr[Math.floor(Math.random() * arr.length)];\n}\n\nconst currentYear = new Date().getFullYear();\nconst lang = language === 'de' ? 'de' : 'en';\n\n// Generiere Content Pieces für jeden Cluster\nconst enrichedClusters = clusters.map(cluster => {\n  const contentPieces = [];\n  \n  // 1. Pillar Page\n  const pillarKeyword = cluster.core_keyword;\n  const pillarVars = {\n    keyword: capitalize(pillarKeyword),\n    year: currentYear,\n    use_case_1: 'Unternehmen',\n    use_case_2: 'Freelancer'\n  };\n  \n  const pillarTitle = fillTemplate(selectRandom(titleTemplates.pillar[lang]), pillarVars);\n  const pillarOutline = outlineTemplates.pillar[lang].map(item => ({\n    h: item.h,\n    t: fillTemplate(item.t, { ...pillarVars, title: pillarTitle })\n  }));\n  \n  // Sekundäre Keywords für Pillar (Top 8 aus Cluster)\n  const secondaryKeywords = cluster.keywords\n    .filter(kw => kw !== pillarKeyword)\n    .slice(0, 8);\n  \n  contentPieces.push({\n    type: 'pillar',\n    slug: slugify(pillarKeyword),\n    title: pillarTitle,\n    primary_keyword: pillarKeyword,\n    secondary_keywords: secondaryKeywords,\n    intent: 'informational',\n    funnel_stage: 'TOFU',\n    recommended_word_count: 2500,\n    outline: pillarOutline,\n    faq: faqTemplates[lang].slice(0, 5).map(q => fillTemplate(q, { keyword: pillarKeyword }))\n  });\n  \n  // 2. Supporting Articles\n  const supportingKeywords = cluster.keyword_details\n    .filter(kw => kw.keyword !== pillarKeyword)\n    .sort((a, b) => b.volume - a.volume)\n    .slice(0, supportingPerCluster);\n  \n  supportingKeywords.forEach((kwData, idx) => {\n    const kw = kwData.keyword;\n    const vars = { keyword: capitalize(kw), year: currentYear };\n    const title = fillTemplate(selectRandom(titleTemplates.supporting[lang]), vars);\n    const outline = outlineTemplates.supporting[lang].map(item => ({\n      h: item.h,\n      t: fillTemplate(item.t, { ...vars, title: title })\n    }));\n    \n    // Intent und Funnel Stage\n    let intent = kwData.intent_guess || 'informational';\n    let funnelStage = 'TOFU';\n    if (intent === 'commercial') funnelStage = 'MOFU';\n    if (intent === 'transactional') funnelStage = 'BOFU';\n    \n    contentPieces.push({\n      type: 'supporting',\n      slug: slugify(kw),\n      title: title,\n      primary_keyword: kw,\n      secondary_keywords: cluster.keywords.filter(k => k !== kw).slice(0, 5),\n      intent: intent,\n      funnel_stage: funnelStage,\n      recommended_word_count: 1200,\n      outline: outline,\n      faq: faqTemplates[lang].slice(2, 6).map(q => fillTemplate(q, { keyword: kw }))\n    });\n  });\n  \n  // 3. Commercial Piece (optional)\n  if (includeCommercial) {\n    const commercialKeyword = `beste ${pillarKeyword}`;\n    const vars = {\n      keyword: capitalize(pillarKeyword),\n      year: currentYear,\n      option_1: 'Option A',\n      option_2: 'Option B'\n    };\n    const title = fillTemplate(selectRandom(titleTemplates.commercial[lang]), vars);\n    const outline = outlineTemplates.commercial[lang].map(item => ({\n      h: item.h,\n      t: fillTemplate(item.t, { ...vars, title: title })\n    }));\n    \n    contentPieces.push({\n      type: 'commercial',\n      slug: slugify(`beste-${pillarKeyword}`),\n      title: title,\n      primary_keyword: commercialKeyword,\n      secondary_keywords: [`${pillarKeyword} vergleich`, `${pillarKeyword} test`, `${pillarKeyword} anbieter`],\n      intent: 'commercial',\n      funnel_stage: 'MOFU',\n      recommended_word_count: 1800,\n      outline: outline,\n      faq: [\n        `Welcher ${pillarKeyword}-Anbieter ist der beste?`,\n        `Was kostet ${pillarKeyword}?`,\n        `Worauf sollte man bei ${pillarKeyword} achten?`,\n        `Gibt es kostenlose ${pillarKeyword}-Alternativen?`\n      ]\n    });\n  }\n  \n  return {\n    ...cluster,\n    content_pieces: contentPieces\n  };\n});\n\nreturn [{\n  json: {\n    clusters: enrichedClusters,\n    original_data: originalData,\n    all_keywords: data.all_keywords,\n    data_incomplete: data.data_incomplete,\n    clustering_method: data.clustering_method\n  }\n}];"
      },
      "id": "generate-content-pieces",
      "name": "18 Generate Content Pieces",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4620, 400]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.original_data.llm.provider }}",
              "operation": "notEquals",
              "value2": "none"
            }
          ]
        }
      },
      "id": "check-llm-for-outlines",
      "name": "19 LLM für Outlines?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [4840, 400]
    },
    {
      "parameters": {
        "jsCode": "// Skip LLM Outline Enhancement - nutze Template-basierte Outlines\nreturn $input.all();"
      },
      "id": "skip-llm-outlines",
      "name": "19a Skip LLM Outlines",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5060, 580]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $json.original_data.llm.provider === 'openai' ? 'https://api.openai.com/v1/chat/completions' : 'https://api.anthropic.com/v1/messages' }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "={{ $json.original_data.llm.provider === 'openai' ? 'Authorization' : 'x-api-key' }}",
              "value": "={{ $json.original_data.llm.provider === 'openai' ? 'Bearer ' + $json.original_data.llm.api_key : $json.original_data.llm.api_key }}"
            },
            {
              "name": "={{ $json.original_data.llm.provider === 'anthropic' ? 'anthropic-version' : 'X-Dummy' }}",
              "value": "={{ $json.original_data.llm.provider === 'anthropic' ? '2023-06-01' : 'ignore' }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ (() => {\n  const data = $json;\n  const cluster = data.clusters[0];\n  const pieces = cluster?.content_pieces?.slice(0, 3) || [];\n  \n  const prompt = `Du bist ein SEO-Content-Stratege. Verbessere diese Content-Outlines für maximale SEO-Wirkung.\n\nThema: ${data.original_data.topic}\nZielgruppe: ${data.original_data.target_audience}\n\nAktuelle Outlines:\n${JSON.stringify(pieces.map(p => ({ type: p.type, title: p.title, outline: p.outline })), null, 2)}\n\nVerbessere die Outlines und füge spezifischere H2/H3 Überschriften hinzu. Antworte NUR mit JSON-Array im gleichen Format.`;\n\n  if (data.original_data.llm.provider === 'openai') {\n    return JSON.stringify({\n      model: data.original_data.llm.model || 'gpt-4o-mini',\n      messages: [\n        { role: 'system', content: 'Du bist ein SEO-Experte. Antworte NUR mit validem JSON.' },\n        { role: 'user', content: prompt }\n      ],\n      temperature: 0.7\n    });\n  } else {\n    return JSON.stringify({\n      model: data.original_data.llm.model || 'claude-3-haiku-20240307',\n      max_tokens: 3000,\n      messages: [{ role: 'user', content: prompt }]\n    });\n  }\n})() }}",
        "options": {
          "timeout": 90000
        }
      },
      "id": "llm-enhance-outlines",
      "name": "19b LLM Enhance Outlines",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [5060, 220],
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 3000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM Enhanced Outlines (optional enhancement)\nconst previousData = $('19 LLM für Outlines?').first().json;\nconst llmResponse = $input.first().json;\n\n// Bei Fehler oder leerem Response: Original-Daten zurückgeben\nif (!llmResponse || llmResponse.error) {\n  return [{ json: previousData }];\n}\n\ntry {\n  let content = '';\n  \n  if (llmResponse.choices && llmResponse.choices[0]) {\n    content = llmResponse.choices[0].message.content;\n  } else if (llmResponse.content && llmResponse.content[0]) {\n    content = llmResponse.content[0].text;\n  }\n  \n  // Versuche JSON zu parsen\n  const jsonMatch = content.match(/\\[\\s*\\{[\\s\\S]*\\}\\s*\\]/s);\n  if (jsonMatch) {\n    const enhancedOutlines = JSON.parse(jsonMatch[0]);\n    \n    // Merge enhanced outlines mit bestehenden Daten\n    const clusters = previousData.clusters.map(cluster => {\n      const pieces = cluster.content_pieces.map(piece => {\n        const enhanced = enhancedOutlines.find(e => e.title === piece.title);\n        if (enhanced && enhanced.outline) {\n          return { ...piece, outline: enhanced.outline };\n        }\n        return piece;\n      });\n      return { ...cluster, content_pieces: pieces };\n    });\n    \n    return [{\n      json: {\n        ...previousData,\n        clusters: clusters,\n        outlines_enhanced: true\n      }\n    }];\n  }\n} catch (e) {\n  // Bei Fehler: Original zurückgeben\n}\n\nreturn [{ json: previousData }];"
      },
      "id": "parse-enhanced-outlines",
      "name": "19c Parse Enhanced Outlines",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5280, 220]
    },
    {
      "parameters": {
        "mode": "combine",
        "mergeByFields": {
          "values": [
            {
              "field1": "original_data.request_id",
              "field2": "original_data.request_id"
            }
          ]
        },
        "options": {}
      },
      "id": "merge-outlines",
      "name": "20 Merge Outlines",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [5500, 400]
    },
    {
      "parameters": {
        "jsCode": "// Final JSON Assembly - Baue das vollständige Response-Objekt\nconst data = $input.first().json;\nconst originalData = data.original_data;\n\n// Assumptions aktualisieren\nconst assumptions = [...(originalData.assumptions || [])];\n\nif (data.data_incomplete) {\n  assumptions.push('DATAFORSEO-Daten unvollständig - Fallback-Daten verwendet');\n}\n\nif (data.clustering_method === 'heuristic') {\n  assumptions.push('Clustering wurde heuristisch durchgeführt (kein LLM)');\n}\n\nif (!data.outlines_enhanced) {\n  assumptions.push('Outlines wurden template-basiert generiert (kein LLM-Enhancement)');\n}\n\n// Formatiere Keywords für Output\nconst formattedKeywords = data.all_keywords.map(kw => ({\n  keyword: kw.keyword,\n  volume: kw.volume,\n  cpc: kw.cpc,\n  difficulty: kw.difficulty,\n  intent_guess: kw.intent_guess,\n  parent_topic_guess: kw.parent_topic_guess,\n  source: kw.source\n}));\n\n// Formatiere Clusters für Output\nconst formattedClusters = data.clusters.map(cluster => ({\n  cluster_name: cluster.cluster_name,\n  core_keyword: cluster.core_keyword,\n  cluster_goal: cluster.cluster_goal,\n  keywords: cluster.keywords,\n  content_pieces: cluster.content_pieces.map(piece => ({\n    type: piece.type,\n    slug: piece.slug,\n    title: piece.title,\n    primary_keyword: piece.primary_keyword,\n    secondary_keywords: piece.secondary_keywords,\n    intent: piece.intent,\n    funnel_stage: piece.funnel_stage,\n    recommended_word_count: piece.recommended_word_count,\n    outline: piece.outline,\n    faq: piece.faq\n  }))\n}));\n\n// Content Statistiken\nconst stats = {\n  total_keywords: formattedKeywords.length,\n  total_clusters: formattedClusters.length,\n  total_content_pieces: formattedClusters.reduce((sum, c) => sum + c.content_pieces.length, 0),\n  pillar_pages: formattedClusters.reduce((sum, c) => sum + c.content_pieces.filter(p => p.type === 'pillar').length, 0),\n  supporting_articles: formattedClusters.reduce((sum, c) => sum + c.content_pieces.filter(p => p.type === 'supporting').length, 0),\n  commercial_pieces: formattedClusters.reduce((sum, c) => sum + c.content_pieces.filter(p => p.type === 'commercial').length, 0),\n  estimated_total_words: formattedClusters.reduce((sum, c) => \n    sum + c.content_pieces.reduce((s, p) => s + p.recommended_word_count, 0), 0\n  )\n};\n\n// Finales Response-Objekt\nconst response = {\n  success: true,\n  meta: {\n    topic: originalData.topic,\n    language: originalData.language,\n    location: originalData.location,\n    generated_at: originalData.generated_at,\n    request_id: originalData.request_id,\n    assumptions: assumptions,\n    statistics: stats,\n    data_quality: {\n      dataforseo_success: !data.data_incomplete,\n      clustering_method: data.clustering_method,\n      outlines_enhanced: data.outlines_enhanced || false\n    }\n  },\n  topic_definition: {\n    normalized_topic: originalData.topic,\n    target_audience: originalData.target_audience,\n    business_goal: originalData.business_goal,\n    primary_intent: originalData.primary_intent,\n    tone_angle: originalData.tone_angle,\n    seed_keywords: originalData.seed_keywords\n  },\n  keywords: formattedKeywords,\n  clusters: formattedClusters\n};\n\nreturn [{ json: response }];"
      },
      "id": "final-json-assembly",
      "name": "21 Final JSON Assembly",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5720, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json; charset=utf-8"
              }
            ]
          }
        }
      },
      "id": "respond-success",
      "name": "22 Respond Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [5940, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 400,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json; charset=utf-8"
              }
            ]
          }
        }
      },
      "id": "respond-error",
      "name": "22a Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [880, 480]
    },
    {
      "parameters": {
        "jsCode": "// Global Error Handler - Fängt unerwartete Fehler ab\nconst error = $input.first().json;\n\nconst errorResponse = {\n  success: false,\n  error: {\n    message: 'Ein unerwarteter Fehler ist aufgetreten',\n    details: error.message || error.error || 'Unbekannter Fehler',\n    node: error.node || 'unknown',\n    timestamp: new Date().toISOString()\n  },\n  meta: {\n    suggestion: 'Bitte überprüfen Sie die Eingabeparameter und versuchen Sie es erneut.',\n    support: 'Bei wiederholten Fehlern kontaktieren Sie den Support.'\n  }\n};\n\nreturn [{ json: errorResponse }];"
      },
      "id": "global-error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5940, 600]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 500,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json; charset=utf-8"
              }
            ]
          }
        }
      },
      "id": "respond-global-error",
      "name": "22b Respond Global Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [6160, 600]
    }
  ],
  "connections": {
    "01 Webhook Trigger": {
      "main": [
        [
          {
            "node": "02 Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "02 Validate Input": {
      "main": [
        [
          {
            "node": "03 Check Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "03 Check Validation": {
      "main": [
        [
          {
            "node": "04 Normalize Defaults",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "03a Validation Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "03a Validation Error": {
      "main": [
        [
          {
            "node": "22a Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "04 Normalize Defaults": {
      "main": [
        [
          {
            "node": "05 Seeds vorhanden?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "05 Seeds vorhanden?": {
      "main": [
        [
          {
            "node": "08 Prepare DataForSEO Batches",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "06 LLM für Seeds?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "06 LLM für Seeds?": {
      "main": [
        [
          {
            "node": "06b LLM Generate Seeds",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "06a Generate Seeds (Heuristic)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "06a Generate Seeds (Heuristic)": {
      "main": [
        [
          {
            "node": "07 Merge Seeds",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "06b LLM Generate Seeds": {
      "main": [
        [
          {
            "node": "06c Parse LLM Seeds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "06c Parse LLM Seeds": {
      "main": [
        [
          {
            "node": "07 Merge Seeds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "07 Merge Seeds": {
      "main": [
        [
          {
            "node": "08 Prepare DataForSEO Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "08 Prepare DataForSEO Batches": {
      "main": [
        [
          {
            "node": "09 Split Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "09 Split Batches": {
      "main": [
        [
          {
            "node": "10 DataForSEO Search Volume",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "10 DataForSEO Search Volume": {
      "main": [
        [
          {
            "node": "11 Wait (Rate Limit)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "11 Wait (Rate Limit)": {
      "main": [
        [
          {
            "node": "12 DataForSEO Related Keywords",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "12 DataForSEO Related Keywords": {
      "main": [
        [
          {
            "node": "13 Parse DataForSEO Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "13 Parse DataForSEO Results": {
      "main": [
        [
          {
            "node": "09 Split Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "09 Split Batches": {
      "main": [
        [
          {
            "node": "10 DataForSEO Search Volume",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "14 Collect All Keywords",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "14 Collect All Keywords": {
      "main": [
        [
          {
            "node": "15 Keyword Cleaning & Scoring",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "15 Keyword Cleaning & Scoring": {
      "main": [
        [
          {
            "node": "16 LLM für Clustering?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "16 LLM für Clustering?": {
      "main": [
        [
          {
            "node": "16b LLM Clustering",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "16a Cluster (Heuristic)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "16a Cluster (Heuristic)": {
      "main": [
        [
          {
            "node": "17 Merge Clusters",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "16b LLM Clustering": {
      "main": [
        [
          {
            "node": "16c Parse LLM Clusters",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "16c Parse LLM Clusters": {
      "main": [
        [
          {
            "node": "17 Merge Clusters",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "17 Merge Clusters": {
      "main": [
        [
          {
            "node": "18 Generate Content Pieces",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "18 Generate Content Pieces": {
      "main": [
        [
          {
            "node": "19 LLM für Outlines?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "19 LLM für Outlines?": {
      "main": [
        [
          {
            "node": "19b LLM Enhance Outlines",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "19a Skip LLM Outlines",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "19a Skip LLM Outlines": {
      "main": [
        [
          {
            "node": "20 Merge Outlines",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "19b LLM Enhance Outlines": {
      "main": [
        [
          {
            "node": "19c Parse Enhanced Outlines",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "19c Parse Enhanced Outlines": {
      "main": [
        [
          {
            "node": "20 Merge Outlines",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "20 Merge Outlines": {
      "main": [
        [
          {
            "node": "21 Final JSON Assembly",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "21 Final JSON Assembly": {
      "main": [
        [
          {
            "node": "22 Respond Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "22b Respond Global Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "tags": [
    {
      "id": "1",
      "name": "SEO"
    },
    {
      "id": "2",
      "name": "Content Planning"
    },
    {
      "id": "3",
      "name": "Keyword Research"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2026-01-25T00:00:00.000Z",
  "versionId": "1"
}
