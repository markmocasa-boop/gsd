---
phase: 01-plugin-format
plan: 01
type: execute
depends_on: []
files_modified: [get-shit-done/templates/plugin/plugin.json, get-shit-done/references/plugin-format.md]
---

<objective>
Define the plugin manifest schema (plugin.json) that describes plugin metadata, capabilities, and requirements.

Purpose: Establish the standard contract between plugins and the GSD plugin system. The manifest tells GSD what the plugin provides, what it needs, and how to activate it.

Output:
- `get-shit-done/templates/plugin/plugin.json` - Template manifest with examples
- `get-shit-done/references/plugin-format.md` - Reference documentation for manifest fields
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md

**Design constraints from PROJECT.md:**
- Zero npm dependencies in plugin system core
- Self-contained plugins (dependencies live in plugin folder)
- Unified format that scales from simple to complex
- Package-manager style installation from git repos

**Key patterns from existing codebase:**
- YAML frontmatter for metadata (see command files)
- JSON for configuration (config.json)
- Semantic versioning for packages
</context>

<tasks>

<task type="auto">
  <name>Task 1: Design plugin manifest schema</name>
  <files>get-shit-done/templates/plugin/plugin.json</files>
  <action>
Create `get-shit-done/templates/plugin/plugin.json` with the following schema:

**Required fields:**
- `name`: Plugin identifier (kebab-case, e.g., "neo4j-knowledge-graph")
- `version`: Semver string (e.g., "1.0.0")
- `description`: One-line description
- `author`: Author name or object with name/email/url

**Optional fields:**
- `repository`: Git URL for the plugin source
- `license`: SPDX license identifier
- `keywords`: Array of discovery tags
- `gsd`: Object with GSD-specific configuration:
  - `minVersion`: Minimum GSD version required (e.g., "1.4.0")
  - `commands`: Array of command definitions the plugin provides
  - `workflows`: Array of workflow files the plugin provides
  - `agents`: Array of agent definitions the plugin provides
  - `hooks`: Object mapping GSD lifecycle events to handler files
  - `services`: Object for Docker/service configuration (Phase 5 will elaborate)

**Example structure:**
```json
{
  "name": "example-plugin",
  "version": "1.0.0",
  "description": "Example GSD plugin",
  "author": "Developer Name",
  "repository": "https://github.com/user/gsd-example-plugin",
  "license": "MIT",
  "keywords": ["example", "demo"],
  "gsd": {
    "minVersion": "1.4.0",
    "commands": [
      { "name": "example:hello", "file": "commands/hello.md" }
    ],
    "workflows": [],
    "agents": [],
    "hooks": {},
    "services": null
  }
}
```

Include inline comments (as a separate .md file since JSON doesn't support comments) explaining each field.

Do NOT over-design - keep optional fields minimal. The manifest should be readable by humans and parseable by the install.js script.
  </action>
  <verify>cat get-shit-done/templates/plugin/plugin.json | jq . (valid JSON)</verify>
  <done>plugin.json template exists with required and optional fields documented</done>
</task>

<task type="auto">
  <name>Task 2: Create plugin format reference documentation</name>
  <files>get-shit-done/references/plugin-format.md</files>
  <action>
Create `get-shit-done/references/plugin-format.md` documenting:

1. **Manifest Schema** - All fields with types, required/optional status, examples
2. **Command Registration** - How commands array maps to /plugin:command-name
3. **Workflow Registration** - How workflows integrate with existing GSD workflows
4. **Agent Registration** - How agents become available for subagent spawning
5. **Hooks Overview** - Brief intro (detailed in 01-03-PLAN.md)
6. **Services Overview** - Brief intro (detailed in Phase 5)
7. **Validation Rules** - What makes a valid manifest (name format, version format, file paths must exist)

Use the same style as existing reference docs (plan-format.md, checkpoints.md):
- XML semantic containers for sections
- Practical examples in code blocks
- Anti-patterns section showing what NOT to do

Keep it concise - this is a reference, not a tutorial. Phase 6 (Documentation) will create the tutorial.
  </action>
  <verify>cat get-shit-done/references/plugin-format.md | head -50 (file exists with expected structure)</verify>
  <done>plugin-format.md reference exists with schema documentation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `get-shit-done/templates/plugin/plugin.json` exists and is valid JSON
- [ ] `get-shit-done/references/plugin-format.md` exists with schema docs
- [ ] Example in template shows both simple (command-only) and complex (services) plugin shapes
- [ ] No breaking changes to existing GSD structure
</verification>

<success_criteria>

- Both files created
- Manifest schema is complete enough for Phase 2 (installation) to parse
- Documentation follows existing GSD reference style
- Schema supports the Neo4j example from PROJECT.md (commands, hooks, services)
</success_criteria>

<output>
After completion, create `.planning/phases/01-plugin-format/01-01-SUMMARY.md`
</output>
