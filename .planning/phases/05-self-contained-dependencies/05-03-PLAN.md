---
phase: 05-self-contained-dependencies
plan: 03
type: execute
depends_on: ["05-01"]
files_modified: [bin/plugin.js, get-shit-done/references/plugin-format.md]
---

<objective>
Add container cleanup on plugin uninstall and document the complete service lifecycle.

Purpose: Ensure plugins with services clean up properly and developers understand the lifecycle.
Output: Containers removed on uninstall, comprehensive documentation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior plan context:**
@.planning/phases/05-self-contained-dependencies/05-01-SUMMARY.md

**Key files:**
@bin/plugin.js
@get-shit-done/references/plugin-format.md

**Tech stack:** Node.js built-ins only
**Established patterns:**
- stopServices(pluginName) stops containers with `docker compose down`
- getServiceConfig(pluginName) reads service configuration
**Constraining decisions:**
- Uninstall should remove containers AND volumes (clean slate)
- Documentation updates go in plugin-format.md services section
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add container cleanup to uninstall</name>
  <files>bin/plugin.js</files>
  <action>
Add cleanupServices() function and integrate with uninstallPlugin():

1. Add `cleanupServices(pluginName, composePath)` function:
   - Takes pluginName and explicit composePath (since we read manifest before deletion)
   - Call isDockerAvailable(), return early with warning if not available
   - Run: `{dockerCommand} -f {composePath} down -v --remove-orphans`
     - `-v` removes named volumes defined in compose file
     - `--remove-orphans` removes containers not defined in compose file
   - Log: "Cleaning up containers and volumes for {pluginName}..."
   - On success: "Containers and volumes removed"
   - On failure: Log warning but continue with uninstall (don't block file removal)

2. Modify uninstallPlugin() - before removing files:
   - After reading manifest, check if manifest.gsd?.services?.docker-compose exists
   - If yes, build full compose path: `~/.claude/{pluginName}/{services.docker-compose}`
   - Call cleanupServices(pluginName, composePath) before any fs.rmSync calls
   - This ensures cleanup runs while compose file still exists

3. Update dry-run output to show "Would stop and remove containers" if services exist

The cleanup must happen BEFORE file deletion because:
- docker compose needs the compose file to identify containers
- Once files are deleted, we lose the ability to clean up properly
  </action>
  <verify>node -c bin/plugin.js (syntax check passes)</verify>
  <done>
- cleanupServices() function added with -v --remove-orphans flags
- uninstallPlugin() calls cleanupServices() before file removal
- Dry-run shows container cleanup would occur
  </done>
</task>

<task type="auto">
  <name>Task 2: Document complete service lifecycle</name>
  <files>get-shit-done/references/plugin-format.md</files>
  <action>
Update the <services_overview> section in plugin-format.md with complete lifecycle documentation:

Replace the existing "Service lifecycle" bullet points with a comprehensive lifecycle section:

```markdown
**Service lifecycle:**

| Event | Action | Command |
|-------|--------|---------|
| Plugin install | Start services | `docker compose up -d` |
| Plugin enable | Start services | `docker compose up -d` |
| Plugin disable | Stop services | `docker compose down` |
| Plugin uninstall | Remove containers + volumes | `docker compose down -v --remove-orphans` |

**Lifecycle details:**

1. **On install:** Services start automatically if Docker is available. Plugin remains installed even if Docker is unavailable.

2. **On enable:** Services start. If Docker is unavailable, plugin is enabled but services won't run (warning shown).

3. **On disable:** Services stop. Containers are stopped but not removed. Data volumes are preserved.

4. **On uninstall:** Full cleanup - containers stopped, removed, and named volumes deleted. This ensures a clean slate for reinstallation.

**Health checks:**

If `healthCheck` script is provided, it runs when:
- Displaying plugin info (`plugin info <name>`)
- The script should exit 0 for healthy, non-zero for unhealthy
- Health check output is captured for error reporting

**Docker requirements:**

- Docker Desktop or Docker Engine must be installed
- `docker compose` (v2) or `docker-compose` (v1) command must be available
- If Docker is unavailable, plugin operations succeed with warnings
- Services are optional - plugins work without Docker if no services defined
```

Also add a note about volume persistence in the example docker-compose.yml:

```markdown
**Note on volumes:**
Named volumes (like `neo4j_data`) persist across container restarts but are deleted on uninstall. For data that should survive uninstall, use bind mounts to a location outside `~/.claude/`.
```
  </action>
  <verify>Read get-shit-done/references/plugin-format.md and confirm services_overview section is updated</verify>
  <done>
- Service lifecycle table added with all events
- Lifecycle details explain each event
- Health check documentation added
- Docker requirements documented
- Volume persistence note added
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `node -c bin/plugin.js` passes (no syntax errors)
- [ ] cleanupServices() function exists and uses -v --remove-orphans
- [ ] uninstallPlugin() calls cleanupServices() before file removal
- [ ] plugin-format.md has complete service lifecycle documentation
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Uninstall properly cleans up containers and volumes
- Documentation covers full service lifecycle
- Phase 5 complete
</success_criteria>

<output>
After completion, create `.planning/phases/05-self-contained-dependencies/05-03-SUMMARY.md`
</output>
