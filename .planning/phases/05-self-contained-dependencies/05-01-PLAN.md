---
phase: 05-self-contained-dependencies
plan: 01
type: execute
depends_on: []
files_modified: [bin/plugin.js]
---

<objective>
Implement Docker Compose detection and service lifecycle management for plugins.

Purpose: Enable plugins to include self-contained services that start on enable and stop on disable.
Output: Working startServices() and stopServices() functions integrated with enable/disable commands.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior phase context:**
@.planning/phases/04-plugin-activation/04-02-SUMMARY.md

**Key files:**
@bin/plugin.js
@get-shit-done/references/plugin-format.md

**Tech stack:** Node.js built-ins only (fs, path, os, child_process execSync)
**Established patterns:** execSync for external commands (git clone), manifest._installed for tracking state
**Constraining decisions:**
- Zero npm dependencies (PROJECT.md constraint)
- Services field structure: { docker-compose: "path", healthCheck: "path" } (plugin-format.md)
- Enable/disable via manifest._installed.enabled flag (04-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add service lifecycle functions</name>
  <files>bin/plugin.js</files>
  <action>
Add three functions to plugin.js:

1. `isDockerAvailable()` - Check if docker-compose or docker compose is available:
   - Try `execSync('docker compose version', { stdio: 'pipe' })` first (modern Docker)
   - Fallback to `execSync('docker-compose --version', { stdio: 'pipe' })` (legacy)
   - Return object `{ available: boolean, command: 'docker compose' | 'docker-compose' | null }`

2. `getServiceConfig(pluginName)` - Get service configuration from installed manifest:
   - Read `~/.claude/{pluginName}/plugin.json`
   - Return `manifest.gsd?.services` or null if no services
   - Return null gracefully if manifest doesn't exist or is corrupted

3. `startServices(pluginName)` - Start Docker services for a plugin:
   - Call getServiceConfig(pluginName), return early if null
   - Call isDockerAvailable(), error if not available
   - Get docker-compose file path: `~/.claude/{pluginName}/{services.docker-compose}`
   - Verify file exists, error if not
   - Run: `{dockerCommand} -f {composePath} up -d`
   - Log: "Starting services for {pluginName}..."
   - On success: "Services started"
   - On failure: Log error but don't throw (fault isolation per 01-03 decisions)

4. `stopServices(pluginName)` - Stop Docker services for a plugin:
   - Same pattern as startServices
   - Run: `{dockerCommand} -f {composePath} down`
   - Log: "Stopping services for {pluginName}..."
   - On success: "Services stopped"
   - On failure: Log warning but don't throw

Place functions after existing helper functions (after createSymlink, before installPluginFiles).
Use consistent error messaging style with existing code (red/yellow/dim colors).
  </action>
  <verify>node -c bin/plugin.js (syntax check passes)</verify>
  <done>Four functions added: isDockerAvailable(), getServiceConfig(), startServices(), stopServices()</done>
</task>

<task type="auto">
  <name>Task 2: Integrate services with enable/disable commands</name>
  <files>bin/plugin.js</files>
  <action>
Modify enablePlugin() and disablePlugin() functions to call service lifecycle:

1. In enablePlugin() - after setting manifest._installed.enabled = true and writing file:
   - Call startServices(pluginName)
   - Update success message: "Plugin {pluginName} enabled" + if services exist: " (services started)"

2. In disablePlugin() - before setting manifest._installed.enabled = false:
   - Call stopServices(pluginName)
   - Update success message: "Plugin {pluginName} disabled" + if services exist: " (services stopped)"

3. In installPlugin() - after successful installation (before "Done!" message):
   - If plugin has services (check manifest.gsd?.services), call startServices(manifest.name)
   - Plugins are enabled by default on install, so services should start

The service calls should be non-blocking for the enable/disable operation:
- If Docker isn't available, warn but complete the enable/disable
- If services fail to start/stop, warn but complete the operation
- This maintains fault isolation from 01-03 decisions
  </action>
  <verify>
Test scenarios (manual):
1. `node bin/plugin.js enable test-plugin` - should complete even without Docker
2. `node bin/plugin.js disable test-plugin` - should complete even without Docker
  </verify>
  <done>
- enablePlugin() calls startServices() after enabling
- disablePlugin() calls stopServices() before disabling
- installPlugin() calls startServices() for new plugins with services
- All operations complete gracefully if Docker unavailable
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `node -c bin/plugin.js` passes (no syntax errors)
- [ ] `node bin/plugin.js --help` displays help (CLI still works)
- [ ] Functions isDockerAvailable, getServiceConfig, startServices, stopServices exist
- [ ] Enable/disable commands include service lifecycle calls
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors in existing functionality
- Service functions handle missing Docker gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/05-self-contained-dependencies/05-01-SUMMARY.md`
</output>
